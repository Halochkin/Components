<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style type="text/css" rel="stylesheet">
        scale-block-one,
        scale-block-two,
        rotate-block {
            display: inline-block;
            position: relative;
            top: 10px;
            width: 150px;
            height: 150px;
            margin: 50px;
        }

        scale-block-one {
            border: 4px solid red;
        }

        scale-block-two {
            border: 4px solid orange;
        }

        rotate-block {
            border: 4px solid blue;
            border-radius: 0 50% 50% 50%;
        }

        .frame {
            height: 300px;
            width: 1000px;
            border: 2px solid black;
        }


    </style>
    <script src="https://hammerjs.github.io/dist/hammer.js"></script>
    <script src="//cdn.rawgit.com/hammerjs/touchemulator/0.0.2/touch-emulator.js"></script>
    <script> TouchEmulator(); </script>
</head>
<body>

<div class="frame">

    <scale-block-one>Event</scale-block-one>
    <scale-block-two>Callback()</scale-block-two>
    <rotate-block>Event+Callback()</rotate-block>
</div>

<script type="module">
  import {PinchGestureMixin} from '../src/PinchGestureMixin.js'; //test

  function updateQueryStringParam(key, value) {
    let baseUrl = [location.protocol, '//', location.host, location.pathname].join('');
    let urlQueryString = document.location.search;
    let newParam = key + '=' + value,
      params = '?' + newParam;
    // If the "search" string exists, then build params from it
    if (urlQueryString) {
      let keyRegex = new RegExp('([\?&])' + key + '[^&]*');
      // If param exists already, update it
      if (urlQueryString.match(keyRegex) !== null) {
        params = urlQueryString.replace(keyRegex, "$1" + newParam);
      }
    }
    window.history.replaceState({}, "", baseUrl + params);
  }

  class ScaleBlock1 extends PinchGestureMixin(HTMLElement) {

    constructor() {
      super();
      this._pinchStartListener = e => this._onPinchStart(e);
      this._pinchListener = e => this._onPinch(e);
      this._pinchEndListener = e => this._onPinchEnd(e);
      updateQueryStringParam("eventAndOrCallback", 1);
    }

    static get dragFlingEventOrCallback() {
      return 1;
    }

    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("pinchstart", this._pinchStartListener);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.removeEventListener("pinchstart", this._pinchListener);
    }

    _onPinchStart(e) {
      this.addEventListener("pinch", this._pinchListener);
      this.style.backgroundColor = "yellow";
    }

    _onPinch(e) {
      this.addEventListener("pinchend", this._pinchEndListener);
      const width = e.detail.distWidth;
      const height = e.detail.distHeight;
      this.style.transform = `scaleX(${width}) scaleY(${height})`;
    }

    _onPinchEnd(e) {
      this.removeEventListener("pinch", this._pinchStartListener);
      this.removeEventListener("pinchend", this._pinchEndListener);
    }
  }

  class ScaleBlock2 extends PinchGestureMixin(HTMLElement) {

    constructor() {
      super();
      this._pinchStartListener = e => this._onPinchStart(e);
      this._pinchListener = e => this._onPinch(e);
      this._pinchEndListener = e => this._onPinchEnd(e);
      updateQueryStringParam("eventAndOrCallback", -1);
    }

    static get dragFlingEventOrCallback() {
      return -1;
    }

    pinchCallback(pinchDetail) {
      const diagonal = pinchDetail.distDiagonal;
      this.style.transform = `scale(${diagonal})`;
    }
  }

  class RotateBlock extends PinchGestureMixin(HTMLElement) {

    constructor() {
      super();
      this._pinchStartListener = e => this._onPinchStart(e);
      this._pinchListener = e => this._onPinch(e);
      this._pinchEndListener = e => this._onPinchEnd(e);
      updateQueryStringParam("eventAndOrCallback", 0);
    }

    static get dragFlingEventOrCallback() {
      return 0;
    }

    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("pinchstart", this._pinchStartListener);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this.removeEventListener("pinchstart", this._pinchListener);
    }

    _onPinchStart(e) {

      this.addEventListener("pinch", this._pinchListener);
      this.style.border = "2px solid blue";
    }

    _onPinch(e) {
      const lastRotate = this.style.transform ? parseFloat(this.style.transform.substring(7)) : 0;
      this.style.transform = `rotate(${lastRotate + e.detail.rotation}deg)`;
      this.addEventListener("pinchend", this._pinchEndListener);
    }

    _onPinchEnd(e) {
      this.removeEventListener("pinch", this._pinchStartListener);
      this.removeEventListener("pinchend", this._pinchEndListener);
      this.style.border = "2px solid green";
    }

    pinchCallback(pinchDetail) {
      this.style.backgroundColor = "yellow";
    }
  }

  customElements.define("scale-block-one", ScaleBlock1);
  customElements.define("scale-block-two", ScaleBlock2);
  customElements.define("rotate-block", RotateBlock);
</script>
</body>
</html>

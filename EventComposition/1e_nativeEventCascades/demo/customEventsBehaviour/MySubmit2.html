<script>
  const EventRoadMap = {
    UNPREVENTABLES: {
      mousedown: ["contextmenu", "focusin", "focus", "focusout", "blur"],
      mouseup: ["click", "auxclick", "dblclick"],
      click: ["dblclick"],
      keydown: ["keypress"]
    }
  };

  function parseRaceEvents(raceEvents) {
    if (raceEvents instanceof Array)
      return raceEvents;
    if (raceEvents === undefined)
      return [];
    if (raceEvents instanceof String || typeof (raceEvents) === "string")
      return EventRoadMap.UNPREVENTABLES[raceEvents];
    throw new Error(
      "The raceEvent argument in toggleTick(cb, raceEvents) must be undefined, " +
      "an array of event names, empty array, or a string with an event name " +
      "for the trigger event in the event cascade.");
  }

  function toggleTick(cb, raceEvents) {
    raceEvents = parseRaceEvents(raceEvents);
    const details = document.createElement("details");
    details.style.display = "none";
    const internals = {
      events: raceEvents,
      cb: cb
    };

    function wrapper() {
      task.cancel();
      internals.cb();
    }

    const task = {
      cancel: function () {
        for (let raceEvent of internals.events)
          window.removeEventListener(raceEvent, wrapper, true);
        details.ontoggle = undefined;
      },
      reuse: function (newCb, raceEvents) {
        raceEvents = parseRaceEvents(raceEvents);
        internals.cb = newCb;
        for (let raceEvent of internals.events)
          window.removeEventListener(raceEvent, wrapper, true);
        internals.events = raceEvents;
        for (let raceEvent of internals.events)
          window.addEventListener(raceEvent, wrapper, {capture: true});
      },
      isActive: function () {
        return !!details.ontoggle;
      }
    };
    details.ontoggle = wrapper;
    document.body.appendChild(details);
    details.open = true;
    Promise.resolve().then(details.remove.bind(details));
    for (let raceEvent of internals.events)
      window.addEventListener(raceEvent, wrapper, {capture: true});
    return task;
  }

  //requires the toggleTick function
  Object.defineProperty(Event.prototype, "addDefaultAction", {
    value: function (cb, options) {
      let raceEvents = options ? options.raceEvents : undefined;
      if (raceEvents === true)
        raceEvents = this.type;
      return toggleTick(() => cb(this), raceEvents);
    },
    writable: false
  });
</script>


<style>
    my-submit {
        height: 100px;
        width: 250px;
        display: block;
        background-color: #f5ebe0;
        border: 1px solid #21759b;
    }
</style>
<my-submit></my-submit>

<script>

  (function () {
    class MyInput extends HTMLElement {

      static get observedAttributes() {
        return ["value", "type"];
      }

      constructor() {
        super();
        this.shadow = this.attachShadow({mode: "closed"});
        this._onKeypress = this.onKeypress.bind(this);
        this._onKeydown = this.onKeydown.bind(this);
      }


      connectedCallback() {
        this.addEventListener("keypress", this._onKeypress, true);
        this.addEventListener("keydown", this._onKeydown, true);
      }

      disconnectedCallback() {
        this.removeEventListener("keypress", this._onKeypress, true);
        this.removeEventListener("keydown", this._onKeydown, true);
      }

      get value() {
        return this._innerDiv.innerText;
      }

      set value(newValue) {
        this._innerDiv.innerText = newValue;
      }

      onKeydown(e) {
        if (e.key === "Backspace")
          this.value = this.value.slice(0, this.value.length - 1);
      }

      onKeypress(e) {
        if (e.key !== "Enter")
          this.value += e.key;
      }

      attributeChangedCallback(name, oldValue, newValue) {
        this.style.whiteSpace = "break-spaces";
        if (name === "value")
          this.value = newValue;
        else if (name === "type")
          this.shadow.innerHTML = `<div tabindex="0" style=" background-color: ${newValue === "submit" ? "gray" : "white"}; border: 1px solid #4c4a4d; width: 150px; height: 1.2em;"></div>`;
        this._innerDiv = this.shadow.children[0];
      }
    }

    customElements.define("my-input", MyInput);


    class MySubmit extends HTMLElement {
      constructor() {
        super();
        this.shadow = this.attachShadow({mode: "closed"});
        this.shadow.innerHTML = `
            <my-input type="text" value="hello world"></my-input>
<!--            <my-input type="text" value="hello corona"></my-input>-->
            <my-input type="submit" value="Submit"></my-input>`;
        this._onKeypress = this.onKeypress.bind(this);
        this._onClick = this.onClick.bind(this);
      }

      connectedCallback() {
        this.addEventListener("keypress", this._onKeypress, true);
        this.shadow.addEventListener("click", this._onClick, true);
      }

      disconnectedCallback() {
        this.removeEventListener("keypress", this._onKeypress, true);
        this.shadow.removeEventListener("click", this._onClick, true);
      }

      onKeypress(e) {
        if (e.key !== "Enter")
          return;
        const el = this.firstInPath(e.composedPath(), "my-submit");
        if (!el)
          return;
        let textInputs = this.shadow.querySelectorAll("my-input:not([type=reset]):not([type=submit])").length;
        let firstSubmitButton = this.shadow.querySelector("my-input[type=submit]");
        if (textInputs >= 1 && firstSubmitButton)
          firstSubmitButton.click();
        else if (textInputs === 1)
          e.addDefaultAction(el._native_requestSubmit.bind(this), {preventable: el});
      }

      onClick(e) {
        const el = this.firstInPath(e.composedPath(), "my-input[type=submit]");
        if (!el)
          return;
        e.addDefaultAction(this._native_requestSubmit.bind(this), {preventable: el});
      }

      _native_requestSubmit() {
        const beforeInputEvent = new InputEvent("my-submit", {
          composed: false,
          bubbles: true,
          cancelable: true,
          target: this
        });
        this.dispatchEvent(beforeInputEvent);
        // Event listeners in the propagation above might queue microtasks.
        // These microtasks should be emptied before _native_updateValue is called.
        // To delay updating the state properly until these microtasks are run, we use toggleTick.
        // toggleTick(() => {
        //   if (!beforeInputEvent.defaultPrevented)
        //     console.log("prevented");
        // }, ["keypress"]);   //keydown might trigger keypress.
      }

      firstInPath(path, query) {
        for (let element of path) {
          if (element instanceof HTMLElement && element.matches(query)) {
            return element;
          }
        }
        return null;
      }


    }

    customElements.define("my-submit", MySubmit);


  }());

  window.addEventListener("my-submit", e => console.log(e.type))


</script>
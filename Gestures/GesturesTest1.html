<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Demo</title>
        <style>
        test-block {
            height: 250px;
            width: 250px;
            background-color: red;
            display: block;
            text-align: center;
            line-height: 15;
            color: white;
            border-radius: 10px;
        }

        switch-button {
            display: inline-flex;
            margin: 100px;
            margin-left: 240px;
            margin-top: -100px;
            position: absolute;
            width: 60px;
        }

        #borD {
            height: 600px;
            width: 600px;
            border: 2px solid black;
            border-radius: 10px;
            margin: 20px;
            box-shadow: 3px 3px;
            text-align: center;
            font-family: 'Baskerville Old Face', sans-serif;
        }
    </style>
</head>
<body>
<div id="borD">
   <span>Activate gestures using the radio buttons.
        The first time the event is activated, it will be simulated programmatically.
        Once activated, you can use the mouse or sensor.</span>
    <test-block id="controller"></test-block>
</div>
<switch-button id="buttons"></switch-button>
<script type="module">

  import {DragFlingGesture} from "https://rawgit.com/Halochkin/Components/master/Gestures/DragFlingMixin/src/DragFlingGestureMixin.js";
  import {PinchGesture} from "https://rawgit.com/Halochkin/Components/master/Gestures/PinchGestureMixin/src/PinchMixin.js";
  import {SwipeGesture} from "https://rawgit.com/Halochkin/Components/master/Gestures/SwipeGestureMixin/src/SwipeGesture.js";
  import {simulateEventSequence} from "https://rawgit.com/Halochkin/Components/master/Gestures/EventSimulator/src/EventSimulator.js";

 class TestBlock extends SwipeGesture(DragFlingGesture(PinchGesture(HTMLElement))) {

    constructor() {
      super();
      this._onPinchListener = e => this.onPinch(e);
      this._onSpinListener = e => this.onSpin(e);
      this._switcherListener = e => this.onSwitch(e);
      this._dragListener = e => this.onDrag(e);
      this._flingListener = e => this.onFling(e);
      this.lastListener = [""]; // value of the last eventListener.
    }

    static get pinchEvent() {
      return true;
    }

    static get dragEvent() {
      return true;
    }

    connectedCallback() {
      super.connectedCallback();
      this.style.marginTop = "175px";
      this.style.marginLeft = "175px";
      this.style.font = "Arial";
      document.getElementById("buttons").addEventListener("buttons-select", this._switcherListener);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      document.getElementById("buttons").removeEventListener("buttons-select", this._switcherListener);
    }

    onSwitch(event) {
      const myElement = document.getElementById('controller');
      switch (event.detail) {    // the switch value of radio buttons
        case "pinch":
          this.addEventListener("pinch", this._onPinchListener);
          simulateEventSequence([     // before you start to simulate events - specify the sequence of events to call the desired events.
            [myElement, "start", 1],  // to dispatch an event to an element - you can use simulateEventSequence(element, event type, number of touch points).
            [myElement, "start", 2],  // for example, the "pinch" event starts with one finger touching - then two fingers touching, so the start event is called twice.
            [myElement, "move", 2],
            [myElement, "end", 2]
          ]);
          //Remove the last value from the array. This is to avoid conflicts when changing an event.
          // For example, the fling event is a continuation of the drag event.
          // "Fling" event always activates the "drag" event and if the necessary conditions are met - "fling".
          // To do this, you need to delete the previous event listeners. If you do not do this, several events
          // will be triggered at the same time.
          break;
        case "spin":
          this.addEventListener("spin", this._onSpinListener);
          simulateEventSequence([
            [myElement, "start", 1],
            [myElement, "start", 2],
            [myElement, "move", 2]
          ]);
          setTimeout(function () {
            simulateEventSequence([[myElement, "end", 2]])
          }, 120);          // If you have some time limits - you can add a delay.
                            // For example, to meet the 'spin' conditions, the delay between the 'move' and 'end'
                            // must be longer than 100ms.
          break;
        case "dragging":
          this.addEventListener("dragging", this._dragListener);
          simulateEventSequence([
            [myElement, "start", 1],
            [myElement, "move", 1],
            [myElement, "end", 1]
          ]);
          break;
        case "fling":
          this.addEventListener("fling", this._flingListener);
          simulateEventSequence([[myElement, "start", 1],
            setTimeout(function () {
              simulateEventSequence([[myElement, "move", 1]])
            }, 100)]);
          setTimeout(function () {
            simulateEventSequence([[myElement, "end", 1]])
          }, 250);
          break;
        case "swipe":
          this.addEventListener("swipeend", this._swipeListener);
          this.lastListener.push([event.detail, this._swipeListener]);
          simulateEventSequence([
            [myElement, "start", 2],
            [myElement, "move", 2],
            [myElement, "end", 2]
          ]);
          this.removeEventListener(this.lastListener[this.lastListener.length - 1][0], this.lastListener[this.lastListener.length - 1][1]);
          break;
      }
    }

    onPinch(e) {
      let prevSpinAngle = (this.style.transform ? parseFloat(this.style.transform.substring(7)) : 0);
      this.style.transform = `rotate(${prevSpinAngle + e.detail.rotation}deg)`;
      this.style.backgroundColor = "green";
      this.style.border = "1px solid black";
      this.style.borderRadius = '60px 60px';
      this.style.transition = "2s";
      this.innerText = "PINCH";
    }

    onSpin(e) {
      let prevSpinAngle = (this.style.transform ? parseFloat(this.style.transform.substring(7)) : 0);
      this.style.transform = `rotate(${prevSpinAngle + e.detail.rotation * 5}deg)`;
      this.style.backgroundColor = "yellow";
      this.style.borderRadius = '155px 25px';
      this.style.transition = "1s";
      this.innerText = "SPIN";
    }

    onDrag(e) {
      this.style.marginTop = (parseFloat(this.style.marginTop) + e.detail.distY) + "px";
      this.style.marginLeft = (parseFloat(this.style.marginLeft) + e.detail.distX) + "px";
      this.style.backgroundColor = "rgba(13, 129, 195, 0.58)";
      this.style.borderRadius = "50%";
      this.style.border = "10px solid pink";
      this.style.transition = "0s";
      this.innerText = "DRAG";
      this.checkFunc();
    }

    onFling(e) {
      const totalTime = e.detail.durationMs;
      this.style.marginTop = (parseFloat(this.style.marginTop) + e.detail.distY * 2) + "px";
      this.style.marginLeft = (parseFloat(this.style.marginLeft) + e.detail.distX * 2) + "px";
      this.style.transition = "all " + totalTime + "ms cubic-bezier(0.39, 0.58, 0.57, 1)";
      this.style.backgroundColor = "#3fc352b0";
      this.style.border = "10px solid red";
      this.style.borderRadius = "50%";
      this.style.transition = "0.3s";
      this.innerText = "FLING";
      this.checkFunc();

    }


    //To ensure that the block does not leave the window border, this simple function is added,
    // which is called every time after onDrag(e) and onFling(e).
    checkFunc() {
      if (parseFloat(this.style.marginTop )< 10) {
        this.style.marginTop = "0px";
      }
      if (parseFloat(this.style.marginLeft) < 10) {
        this.style.marginLeft = "0px";
      }
    }
  }

  class SwitchButtons extends PinchGesture(HTMLElement) {
    constructor() {
      super();
      this.innerHTML = `
    <input type="radio" id="pinch" name="check"><label>Pinch</label>
    <input type="radio" id="spin" name="check" ><label>Spin</label>
    <input type="radio" id="dragging" name="check"><label>Drag</label><br>
    <input type="radio" id="fling" name="check"><label>Fling</label>`;
      this.addEventListener("click", e => {
        this.dispatchEvent(new CustomEvent("buttons-select", {composed: true, bubbles: true, detail: e.target.id}));
      });
    }
  }

  customElements.define("test-block", TestBlock);
  customElements.define("switch-button", SwitchButtons);

</script>
</body>
</html>
